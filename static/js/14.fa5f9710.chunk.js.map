{"version":3,"sources":["Hooks/FocusInput.ts","Features/WordSearch/WordSearchOutput.tsx","Features/WordSearch/WordSearchComponent.tsx","Features/WordSearch/index.tsx","Hooks/LocalStorage.ts","version.ts","Data/LocalStorage.ts"],"names":["useFocusInput","useCallback","node","focus","splitLines","str","split","getGridHighlights","grid","wordsToFind","direction","canBend","solver","WordSearchSolver","setDirections","setCanBend","setGrid","setWords","inputGrid","results","shouldHighlight","line","hightlightLine","Array","from","length","push","result","points","point","y","x","highlightArray","findWords","getColumnClassName","WordSearchOutput","props","gridInputText","trim","lines","useCardinals","useDiagonals","WordSearchDirection","CardinalAndDiagonal","Cardinal","Diagonal","None","wordListInputText","filter","word","Table","className","borderless","map","row","rowIndex","key","col","colIndex","WordSearchComponent","inputRef","useState","setGridInputText","setWordListInputText","setUseCardinals","setUseDiagonals","useLocalStorage","savedState","Container","fluid","Row","noGutters","Col","md","Card","Header","Body","FormControl","as","onChange","event","currentTarget","value","placeholder","Alert","variant","renderEmptyDirection","FormCheck","checked","id","label","type","ref","spellCheck","WordSearch","localStorageKey","onRestoreState","onSaveState","useLayoutEffect","getLocalStorageObject","useEffect","setLocalStorageObject","version","isSupported","getKey","clearOnVersionMismatch","prev","current","compareVersions","didVersionChange","isLocalStorageSupported","window","localStorage","getItem","getLocalStorageItem","clearLocalStorage","setItem","undefined","storage","removeItem","e","DOMException","code","name","objString","JSON","parse","object","stringify","clear"],"mappings":"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","file":"static/js/14.fa5f9710.chunk.js","sourcesContent":["import { useCallback } from 'react';\n\nexport function useFocusInput() {\n  // This callback is only executed once per change of the returned variable.\n  return useCallback(\n    (node) => {\n      if (node) {\n        node.focus();\n      }\n    },\n    []);\n}\n","import React from 'react';\nimport Table from 'react-bootstrap/Table';\nimport {\n  WordSearchSolver,\n  WordSearchResult,\n  WordSearchDirection,\n} from 'puzzle-lib';\nimport './WordSearchOutput.scss';\n\ninterface Props {\n  gridInputText: string;\n  useCardinals: boolean;\n  useDiagonals: boolean;\n  canBend: boolean;\n  wordListInputText: string;\n}\n\nfunction getWordSearchDirection(useCardinals: boolean, useDiagonals: boolean) {\n  if (useCardinals && useDiagonals) {\n    return WordSearchDirection.CardinalAndDiagonal;\n  } else if (useCardinals) {\n    return WordSearchDirection.Cardinal;\n  } else if (useDiagonals) {\n    return WordSearchDirection.Diagonal;\n  }\n\n  return WordSearchDirection.None;\n}\n\nfunction splitLines(str: string) {\n  return str.split(/\\r?\\n/);\n}\n\nfunction highlightArray(inputGrid: string[][], results: WordSearchResult[]) {\n  const shouldHighlight: boolean[][] = [];\n\n  for (const line of inputGrid) {\n    const hightlightLine = Array.from({ length: line.length }, () => false);\n    shouldHighlight.push(hightlightLine);\n  }\n\n  for (const result of results) {\n    for (const point of result.points) {\n      shouldHighlight[point.y][point.x] = true;\n    }\n  }\n\n  return shouldHighlight;\n}\n\nfunction getGridHighlights(\n  grid: string[][],\n  wordsToFind: string[],\n  direction: WordSearchDirection,\n  canBend: boolean) {\n  const solver = new WordSearchSolver();\n  solver.setDirections(direction);\n  solver.setCanBend(canBend);\n  solver.setGrid(grid);\n  solver.setWords(wordsToFind);\n  const results = solver.findWords();\n\n  return highlightArray(grid, results);\n}\n\nfunction getColumnClassName(shouldHighlight: boolean) {\n  return shouldHighlight ? 'WordSearchOutput-highlightChar' : '';\n}\n\nfunction WordSearchOutput(props: Props) {\n  const gridInputText = props.gridInputText.trim();\n  if (!gridInputText) {\n    return null;\n  }\n\n  const lines = splitLines(gridInputText);\n  const grid: string[][] = [];\n  for (const line of lines) {\n    grid.push(line.split(''));\n  }\n\n  // Process direction settings\n  const direction = getWordSearchDirection(\n    props.useCardinals,\n    props.useDiagonals);\n\n  // Split on newlines, trim any whitespace, and filter out empty lines.\n  const wordList = splitLines(props.wordListInputText)\n    .filter(word => word.length > 0);\n\n  const shouldHighlight = getGridHighlights(grid, wordList, direction, props.canBend);\n\n  return (\n    <Table className=\"WordSearchOutput\" borderless={true}>\n      <tbody>\n        {grid.map((row, rowIndex) => (\n          <tr key={rowIndex}>\n            {row.map((col, colIndex) => (\n              <td\n                className={getColumnClassName(shouldHighlight[rowIndex][colIndex])}\n                key={`${rowIndex},${colIndex}`}\n              >\n                {col}\n              </td>\n            ))}\n          </tr>\n        ))}\n      </tbody>\n    </Table>\n  );\n}\n\nexport default WordSearchOutput;\n","import React, { ChangeEvent, useState } from 'react';\nimport Alert from 'react-bootstrap/Alert';\nimport Card from 'react-bootstrap/Card';\nimport Col from 'react-bootstrap/Col';\nimport Container from 'react-bootstrap/Container';\nimport FormCheck from 'react-bootstrap/FormCheck';\nimport FormControl from 'react-bootstrap/FormControl';\nimport Row from 'react-bootstrap/Row';\nimport { useFocusInput } from '../../Hooks/FocusInput';\nimport { useLocalStorage } from '../../Hooks/LocalStorage';\nimport WordSearchOutput from './WordSearchOutput';\nimport './WordSearchComponent.scss';\n\ninterface SavedState {\n  gridInputText: string;\n  wordListInputText: string;\n  useDiagonals: boolean;\n  useCardinals: boolean;\n  canBend: boolean;\n}\n\nfunction WordSearchComponent() {\n  const inputRef = useFocusInput();\n  const [gridInputText, setGridInputText] = useState('');\n  const [wordListInputText, setWordListInputText] = useState('');\n  const [useCardinals, setUseCardinals] = useState(true);\n  const [useDiagonals, setUseDiagonals] = useState(true);\n  const [canBend, setCanBend] = useState(false);\n\n  useLocalStorage<SavedState>(\n    'WordSearchComponent',\n    (savedState) => {\n      if (savedState) {\n        setGridInputText(savedState.gridInputText);\n        setWordListInputText(savedState.wordListInputText);\n        setUseCardinals(savedState.useCardinals);\n        setUseDiagonals(savedState.useDiagonals);\n        setCanBend(savedState.canBend);\n      }\n    },\n    () => {\n      return {\n        gridInputText,\n        wordListInputText,\n        useCardinals,\n        useDiagonals,\n        canBend,\n      };\n    });\n\n  function onGridTextChanged(event: ChangeEvent<HTMLTextAreaElement>) {\n    setGridInputText(event.currentTarget.value);\n  }\n\n  function onListTextChanged(event: ChangeEvent<HTMLTextAreaElement>) {\n    setWordListInputText(event.currentTarget.value);\n  }\n\n  function onCardinalCheckboxChange(event: ChangeEvent<HTMLInputElement>) {\n    setUseCardinals(event.currentTarget.checked);\n  }\n\n  function onDiagonalCheckboxChange(event: ChangeEvent<HTMLInputElement>) {\n    setUseDiagonals(event.currentTarget.checked);\n  }\n\n  function onSetCanBendChange(event: ChangeEvent<HTMLInputElement>) {\n    setCanBend(event.currentTarget.checked);\n  }\n\n  function renderEmptyDirection() {\n    if (!useCardinals && !useDiagonals) {\n      return (\n        <Alert variant=\"warning\">\n          No directions are selected. No results will be shown.\n        </Alert>\n      );\n    }\n  }\n\n  return (\n    <div className=\"WordSearchComponent\">\n      <Container fluid={true}>\n        <Row noGutters={true}>\n          <Col md={4}>\n            <Card className=\"WordSearchComponent-ListInput\">\n              <Card.Header>\n                Enter the list of words to find, one word per line\n              </Card.Header>\n              <Card.Body>\n                <FormControl\n                  as=\"textarea\"\n                  onChange={onListTextChanged}\n                  placeholder=\"Word List To Find\"\n                  value={wordListInputText}\n                />\n                {renderEmptyDirection()}\n                <FormCheck\n                  checked={useDiagonals}\n                  id=\"WordSearchComponent-checkbox-diagonal\"\n                  label=\"Use diagonal directions\"\n                  onChange={onDiagonalCheckboxChange}\n                  type=\"checkbox\"\n                />\n                <FormCheck\n                  checked={useCardinals}\n                  id=\"WordSearchComponent-checkbox-cardinal\"\n                  label=\"Use cardinal directions\"\n                  onChange={onCardinalCheckboxChange}\n                  type=\"checkbox\"\n                />\n                <FormCheck\n                  checked={canBend}\n                  id=\"WordSearchComponent-checkbox-bend\"\n                  label=\"Words can bend (may not be straight lines)\"\n                  onChange={onSetCanBendChange}\n                  type=\"checkbox\"\n                />\n              </Card.Body>\n            </Card>\n          </Col>\n          <Col md={8}>\n            <Card className=\"WordSearchComponent-GridInput\">\n              <Card.Header>\n                Enter the word search grid, one row of letters per line\n              </Card.Header>\n              <Card.Body>\n                <FormControl\n                  as=\"textarea\"\n                  onChange={onGridTextChanged}\n                  placeholder=\"Grid Text\"\n                  ref={inputRef}\n                  spellCheck={false}\n                  value={gridInputText}\n                />\n              </Card.Body>\n            </Card>\n          </Col>\n        </Row>\n        <Row noGutters={true}>\n          <Col md={12}>\n            <Card className=\"WordSearchComponent-GridOutput\">\n              <Card.Header>Output</Card.Header>\n              <Card.Body>\n                <WordSearchOutput\n                  gridInputText={gridInputText}\n                  useCardinals={useCardinals}\n                  useDiagonals={useDiagonals}\n                  canBend={canBend}\n                  wordListInputText={wordListInputText}\n                />\n              </Card.Body>\n            </Card>\n          </Col>\n        </Row>\n      </Container>\n    </div>\n  );\n}\n\nexport default WordSearchComponent;\n","import React from 'react';\nimport WordSearchComponent from './WordSearchComponent';\nimport './index.scss';\n\nfunction WordSearch() {\n  return (\n    <div className=\"WordSearch\">\n      <h2>Word Search</h2>\n      <WordSearchComponent />\n    </div>\n  );\n}\n\nexport default WordSearch;\n","import { useEffect, useLayoutEffect } from 'react';\nimport { getLocalStorageObject, setLocalStorageObject } from '../Data/LocalStorage';\n\nexport function useLocalStorage<T>(\n  localStorageKey: string,\n  onRestoreState: (state: T | null) => void,\n  onSaveState: () => T) {\n  // This effect runs synchronously on the first mount of the control or\n  // whenever the `localStorageKey` value changes. This is to ensure that there\n  // is no flickering as the data is rendered. `onRestoreState` is intentionally\n  // omitted from deps since each call will have a unique version of the\n  // function.\n  useLayoutEffect(\n    () => onRestoreState(getLocalStorageObject<T>(localStorageKey)),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [localStorageKey]);\n\n  // This effect runs on every update of the control because the deps parameter\n  // is intentionally omitted.\n  useEffect(() => setLocalStorageObject(localStorageKey, onSaveState()));\n}\n","// generated by genversion\nexport const version = '1.0.0';\n","import compareVersions from 'compare-versions';\nimport { version } from '../version';\n\nconst VERSION_STORAGE_KEY = 'appVersion';\nconst STORAGE_KEY_PREFIX = 'puzztool';\nlet isSupported: boolean;\n\nfunction getKey(key: string) {\n  return `${STORAGE_KEY_PREFIX}_${key}`;\n}\n\nfunction didVersionChange(prev: string | null, current: string) {\n  try {\n    if (prev) {\n      return compareVersions(current, prev) !== 0;\n    }\n  } catch {\n    // Something went wrong with parsing.\n  }\n\n  // If there's no existing version number or we had an exception while\n  // comparing it, just return `true` to play it safe.\n  return true;\n}\n\nfunction clearOnVersionMismatch() {\n  const prevVersion = getLocalStorageItem(VERSION_STORAGE_KEY);\n  if (didVersionChange(prevVersion, version)) {\n    // If the current localstorage was created with another version of\n    // PuzzTool, clear the local storage to get rid of any obsolete or\n    // incompatible artifacts.\n    clearLocalStorage();\n\n    // Store the current version\n    setLocalStorageItem(VERSION_STORAGE_KEY, version);\n  }\n}\n\nfunction isLocalStorageSupported() {\n  if (isSupported === undefined) {\n    const storage = window.localStorage;\n    const x = '__storage_test__';\n\n    try {\n      storage.setItem(x, x);\n      storage.removeItem(x);\n      isSupported = true;\n    } catch (e) {\n      isSupported = e instanceof DOMException && (\n        // everything except Firefox\n        e.code === 22 ||\n        // Firefox\n        e.code === 1014 ||\n        // test name field too, because code might not be present\n        // everything except Firefox\n        e.name === 'QuotaExceededError' ||\n        // Firefox\n        e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&\n        // acknowledge QuotaExceededError only if there's something already stored\n        storage.length !== 0;\n    }\n\n    if (isSupported) {\n      clearOnVersionMismatch();\n    }\n  }\n\n  return isSupported;\n}\n\nfunction getLocalStorageItem(key: string) {\n  if (isLocalStorageSupported()) {\n    return window.localStorage.getItem(getKey(key));\n  }\n\n  return null;\n}\n\nfunction setLocalStorageItem(key: string, value: string) {\n  if (isLocalStorageSupported()) {\n    window.localStorage.setItem(getKey(key), value);\n  }\n}\n\nexport function getLocalStorageObject<T>(key: string) {\n  if (isLocalStorageSupported()) {\n    const objString = window.localStorage.getItem(getKey(key));\n\n    if (objString !== null) {\n      return JSON.parse(objString) as T;\n    }\n  }\n\n  return null;\n}\n\nexport function setLocalStorageObject<T>(key: string, object: T) {\n  if (isLocalStorageSupported()) {\n    window.localStorage.setItem(getKey(key), JSON.stringify(object));\n  }\n}\n\nexport function clearLocalStorage() {\n  if (isLocalStorageSupported()) {\n    window.localStorage.clear();\n  }\n}\n"],"sourceRoot":""}